# 葫芦娃对战大实验
## 概念
* 角色 role 代表葫芦娃、妖精、爷爷等各种角色，所以相应地有葫芦娃、妖精、人类的子类。角色有一些属性，姓名如“大娃”、“蝎子精”，阵营属性，葫芦娃和人类属于正义阵营，妖精属于邪恶阵营，还有在棋盘中的位置行列。子类还有自己独特的属性，葫芦娃有自己的排行属性，妖精有本质属性（什么动物化成的妖精），人类有性别属性（无特别作用，只是反应不同角色的独特之处）
* 棋盘 chessboard 有行、列属性，还有role构成的二维数组，二维数组就映射着现实中的棋盘，每一个元素放置一个role，映射棋盘上的角色棋子。
* 阵型 lineup是一个抽象类，阵型包括长蛇阵、鹤翼阵、雁行阵等，每一种具体的阵型会将棋盘上的角色摆成固定模样，但父类阵型本身没有具体功能，所以写成抽象类，方法是抽象方法，由具体的阵型去各自实现
* 对战 fight 将对战抽象出来，分为寻找敌人、走过去、与他对战等步骤
## 机制
* 角色 
1. 跳向指定位置：主要用于棋盘上角色初始化时需要随机放置角色，生成随机数后直接让角色到指定位置
2. 到达新的位置：从随机产生的位置走到阵型要求角色需要到达的位置的位移过程，把位移过程拆解成向上、向下、向左、向右的每一步，这些一小步是private方法以供自身调用。
3. 让路：到达指定位置的一个很大的难题是碰到其他角色挡住自己的路，我设置的机制是角色A被角色B挡住时，会向B发出询问能否让出这个位置而不是绕开B，B会接收到信号，根据A是否和自己同一阵营（妖精不会给葫芦娃让路）以及自己是否有空间给A让路而决定。需要做出改进的地方在于还没有一个很好的call_back算法，让给自己让路的角色依次正确返回
* 棋盘
1. 一个角色改变位置涉及棋盘中数据的变化，和角色本身位置的变化要一致
2. 棋盘的输出： 目前只是按照二维数组的方式格式化输出，阵型也能看出来，但效果并不是达到完美，下一步需要实现输出图形化的棋盘，有横线有竖线
* 泛型
泛型运用在chessboard类中，调用阵型类和其中的排列算法时，阵型和角色是参数化类型，可以对不同的阵型、不同的角色输入进行类型检查，同时运用泛型实现抽象
* 反射
反射运用于角色、棋盘、阵型实例的构造，通过构造器构造任意一个类的对象，并且调用这些对象的方法。可以在运行时进行类型检查，需要抛出一些异常
* 对战
1. 增加角色的攻击力与血量属性，数值是随机生成的，普通的葫芦娃和妖精攻击力在1-5之间波动，血量在20-30之间波动，
2. 由于葫芦娃一方有8人，妖精一方6人，为游戏平衡以及符合动画人设，爷爷的攻击力设为0，血量为100，蛇精攻击力在6-10、血量在40-60，经测试，两边都有赢的可能。
3. 对战时，角色血量清零则死亡，反之继续参与战斗，直到一方失败。
4. 设定为葫芦娃为主动进攻一方，符合动画背景
5. 采用多线程机制，防止角色走到同一个位置
* 前期工作
在前期实验的基础上完成，第四次实验实现静态的排列，于是最终实验先调用第四次实验的类实现静态排列，再开始对战
## 图形化界面
图形化界面暂未实现，先提交中间版本，实验输出是类似前面实验的输出，先输出排列好，对战前的棋盘，最后输出战斗结束后的棋盘剩余角色。图形化的实现仍在开发中
![image](https://github.com/wwuuhan/java-2019-homeworks/blob/master/4-Types/吴晗-161220138/plantUMLclass_homework4.png)
