# JAVA大作业 葫芦娃大战妖精

**171860618 王昆**

## 一 程序介绍
葫芦娃大战妖精是一个能够展现葫芦娃与妖精大战的图形化应用，支持葫芦娃和妖精的列阵、自动战斗、回放功能。 
![83R@@L~VZ8KCP`E4YR_3_88.png](https://i.loli.net/2019/12/29/LWwgyvmu3q1FexY.png)
### 1.运行说明
本项目使用maven工具自动构建。进入程序HuluWa目录，执行mvn clean package打包，打包完成后进入target文件夹，双击打开.jar文件即可运行。 

### 2.操作说明
进入程序后，首先为双方列队就绪状态。此时可以通过屏幕左上或右上角按钮改变双方战斗阵型。  
在就绪状态时，可以选择按空格键可以使双方进入自动战斗状态，或按L键，选择战斗记录txt文件进行回放。  
处于自动战斗状态时，每个生物线程会自动寻敌、移动、攻击，直至其中一方全部死亡。处于回放状态时，会根据选择的文件进行战斗回放。这两种情况下键盘输入无法打断游戏进行，当决出胜负时，可再次按空格键进入准备状态，或按L键选择新的文件，进行新一轮回放。

## 二 设计介绍

### 1.代码框架
![代码结构.jpg](https://i.loli.net/2019/12/29/wctmWX5B7xHVo86.png)

下面对每个类作进一步的功能介绍：  
- 主类Main中进行了所有的必要初始化过程，包括初始化`GameController`的实例，图形化框架的创建以及添加键盘事件的关联。  
- `GameController`和`RecordPlayer`负责交互和控制游戏。其中`GameController`维护游戏的主要状态，负责游戏开始结束、接收键盘事件、判定胜负、设置双方阵型等等。`RecordPlayer`继承`Thread`类，负责文件读入和控制回放。
- `Creature`是具体生物类，在它的两个派生类`GoodCreature`和`BadCreature`中维护了静态变量的双方阵营的生物列表，并且为`GameController`提供了静态的函数接口，可以为双方阵营添加生物、以及改变阵型。生物类继承`Runnable`类，每个生物线程中实现寻敌、移动、攻击等功能逻辑。
- `Formation`类封装了不同阵型的计算方法，根据双方的基础位置、人数、面向方向等参数，提供不同阵型的位置信息。
- `BattleMap`类是双方的战场，维护游戏进行时的双方位置信息(具体方式是维护了以`Position`为键码，以`Creature`为值的`Map`对象)，并且在`BattleMap`中负责对GUI进行更新。
- `Position`类维护了地图网格的位置信息，并且可以进行地图网格位置到画面位置的转换。

### 2.生物逻辑
![生物活动逻辑.jpg](https://i.loli.net/2019/12/29/O574cAspdChemJ8.png)
生物在活动过程中会发消息给`BattleMap`类进行地图上生物位置和状态的更新，并最终由`BattleMap`通知主线程更新UI。当生物移动时，生物线程需等待，直到UI移动动画完成后唤醒线程。当生物受攻击时，会在播放一段短暂的受击动画后死亡，对应图片变为墓碑，留在死亡位置。
### 3.回放功能
回放功能由`RecordPlayer`类，作为一个单独的线程实现控制。首先在生物线程活动时，将移动、受击等信息以固定格式保存在文件中。`RecordPlayer`回放时打开文件依次读取，按照动作的种类以及动作发生的时间对战局进行重现。
### 4.设计模式
在项目设计中体现了以下的设计模式思想：  

#### 单例模式
`GameController`实现为单例模式，在程序入口处调用`GameController.newInstance()`初始化后，全局只可以通过`GameController.getInstance()`访问其实例。

#### 观察者模式 
- `GameCotroller`按照观察者模式进行键盘事件、按钮鼠标事件的监听、处理
- `BattleMap`中，当发生生物移动等更新时，按照观察者模式通知主线程进行UI画面的更新
- 当某一方生物死亡时，按照观察者模式通知主线程的胜负判定通知。

### 5.设计原则
在项目设计中体现了封装、继承和多态的特性，并努力遵循了以下的设计原则：
#### 单一职责原则
对游戏的控制中，将处理回放、阵型设置、状态控制等功能的职责分离，由此产生了`GameController`、`RecordPlayer`和`Formation`等不同的类。同时将生物的自身动作和地图上生物的修改职责相分离，生物的动作完全由`Creature`类维护，而在地图上的更新完全由`BattleMap`类进行控制，
#### 里氏替换法则
在生物的回放、生物间寻敌、攻击以及`BattleMap`的更新等需要引用生物的操作中，对任何生物的操作都是通过其抽象基类`Creature`完成的，而不需要具体的生物。
#### 迪米特法则
所有类的属性都是私有的，并且尽量将对其它对象的引用应该降到最低。
#### 依赖倒置原则
所有依赖生物的场合都依赖实现了`Runnable`接口的生物的抽象基类`Creature`，而不依赖具体的生物类型实现。降低耦合性
## 三 应用JAVA机制  
在项目中应用了Java的异常处理、集合类型、泛型、输入输出等机制。
### 集合类型
`BattleMap`类中维护了生物及其当前位置的映射Map `Map<Position, Creature> characterList`。`GoodCreture`和`BadCreature`分别维护了双方阵营军队的List列表。
### 异常处理
当生物线程被打断或者出现错误、读取回放指令出现错误、游戏控制出现错误等情况下都会抛出异常，并在捕获异常后转入`GameController`的`crashed()`方法中处理，进行游戏状态的重置。
### 输入输出
在读取保存回放指令时，使用了`PrintWriter`、`FileReader`、`BufferedReader`等输入输出工具。
### 类型信息和反射
在为双方阵营添加生物时使用 `instance of`进行类型信息的判断，防止添加非本阵营的生物。